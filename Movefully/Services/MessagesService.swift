import Foundation
import FirebaseFirestore
import FirebaseAuth
import Combine

// MARK: - Messages Service
@MainActor
class MessagesService: ObservableObject {
    private let db = Firestore.firestore()
    nonisolated(unsafe) private var conversationsListener: ListenerRegistration?
    nonisolated(unsafe) private var messagesListener: ListenerRegistration?
    
    // MARK: - Conversation Operations
    
    /// Fetches all conversations for a trainer, including auto-generated ones for active clients
    func fetchTrainerConversations(_ trainerId: String) async throws -> [Conversation] {
        print("üîç MessagesService: Fetching conversations for trainer: \(trainerId)")
        
        // Fetch existing conversations from Firebase
        let conversationsSnapshot = try await db.collection("conversations")
            .whereField("trainerId", isEqualTo: trainerId)
            .order(by: "lastMessageTime", descending: true)
            .getDocuments()
        
        var existingConversations: [Conversation] = []
        var existingClientIds: Set<String> = []
        
        for document in conversationsSnapshot.documents {
            do {
                let data = document.data()
                
                // Handle missing or null fields gracefully
                guard let clientId = data["clientId"] as? String,
                      let clientName = data["clientName"] as? String else {
                    print("‚ùå MessagesService: Skipping conversation with missing clientId or clientName")
                    continue
                }
                
                let conversation = Conversation(
                    id: document.documentID, // Always use document ID
                    trainerId: data["trainerId"] as? String ?? "",
                    clientId: clientId,
                    clientName: clientName,
                    lastMessage: data["lastMessage"] as? String ?? "",
                    lastMessageTime: (data["lastMessageTime"] as? Timestamp)?.dateValue() ?? Date(),
                    unreadCount: data["unreadCount"] as? Int ?? 0
                )
                
                existingConversations.append(conversation)
                existingClientIds.insert(conversation.clientId)
                print("‚úÖ MessagesService: Loaded existing conversation with \(conversation.clientName)")
            } catch {
                print("‚ùå MessagesService: Error decoding conversation: \(error)")
            }
        }
        
        // Deduplicate conversations by client - keep only the most recent per client
        var latestConversationsByClient: [String: Conversation] = [:]
        
        for conversation in existingConversations {
            let clientId = conversation.clientId
            if let existing = latestConversationsByClient[clientId] {
                // Keep the conversation with the most recent message
                if conversation.lastMessageTime > existing.lastMessageTime {
                    latestConversationsByClient[clientId] = conversation
                }
            } else {
                latestConversationsByClient[clientId] = conversation
            }
        }
        
        let deduplicatedConversations = Array(latestConversationsByClient.values)
        let deduplicatedClientIds = Set(deduplicatedConversations.map { $0.clientId })
        
        // Fetch all active clients (not pending) to auto-create conversations
        let activeClients = try await fetchActiveClients(trainerId)
        var autoGeneratedConversations: [Conversation] = []
        
        for client in activeClients {
            // Only create conversation if one doesn't already exist
            if !deduplicatedClientIds.contains(client.id) {
                let autoConversation = Conversation(
                    id: "auto_\(client.id)", // Temporary ID for UI, will be real ID when first message is sent
                    trainerId: trainerId,
                    clientId: client.id,
                    clientName: client.name,
                    lastMessage: "Start a conversation",
                    lastMessageTime: client.lastActivityDate ?? client.createdAt,
                    unreadCount: 0
                )
                autoGeneratedConversations.append(autoConversation)
                print("‚úÖ MessagesService: Auto-generated conversation for active client: \(client.name)")
            }
        }
        
        // Combine deduplicated and auto-generated conversations, sorted by last message time
        let allConversations = (deduplicatedConversations + autoGeneratedConversations)
            .sorted { $0.lastMessageTime > $1.lastMessageTime }
        
        print("‚úÖ MessagesService: Total conversations: \(allConversations.count) (existing: \(existingConversations.count), deduplicated: \(deduplicatedConversations.count), auto-generated: \(autoGeneratedConversations.count))")
        return allConversations
    }
    
    /// Fetches active clients (non-pending) for a trainer
    private func fetchActiveClients(_ trainerId: String) async throws -> [Client] {
        print("üîç MessagesService: Fetching active clients for trainer: \(trainerId)")
        
        let clientsSnapshot = try await db.collection("trainers")
            .document(trainerId)
            .collection("clients")
            .whereField("status", in: ["Active", "Needs Attention", "Paused"]) // All non-pending statuses
            .getDocuments()
        
        var activeClients: [Client] = []
        
        for document in clientsSnapshot.documents {
            do {
                var client = try document.data(as: Client.self)
                client.id = document.documentID
                activeClients.append(client)
                print("‚úÖ MessagesService: Found active client: \(client.name) (status: \(client.status.rawValue))")
            } catch {
                print("‚ùå MessagesService: Error decoding client: \(error)")
            }
        }
        
        print("‚úÖ MessagesService: Found \(activeClients.count) active clients")
        return activeClients
    }
    
    /// Creates or gets existing conversation between trainer and client
    func getOrCreateConversation(trainerId: String, clientId: String, clientName: String) async throws -> String {
        print("üîç MessagesService: Getting/creating conversation between trainer: \(trainerId) and client: \(clientId)")
        
        // First check if conversation already exists
        let existingConversations = try await db.collection("conversations")
            .whereField("trainerId", isEqualTo: trainerId)
            .whereField("clientId", isEqualTo: clientId)
            .getDocuments()
        
        if let existingDoc = existingConversations.documents.first {
            print("‚úÖ MessagesService: Found existing conversation: \(existingDoc.documentID)")
            return existingDoc.documentID
        }
        
        // Create new conversation
        let conversationRef = db.collection("conversations").document()
        let conversationData: [String: Any] = [
            "id": conversationRef.documentID, // Include the document ID as a field
            "trainerId": trainerId,
            "clientId": clientId,
            "clientName": clientName,
            "lastMessage": "",
            "lastMessageTime": FieldValue.serverTimestamp(),
            "unreadCount": 0,
            "createdAt": FieldValue.serverTimestamp(),
            "updatedAt": FieldValue.serverTimestamp()
        ]
        
        try await conversationRef.setData(conversationData)
        print("‚úÖ MessagesService: Created new conversation: \(conversationRef.documentID)")
        return conversationRef.documentID
    }
    
    // MARK: - Message Operations
    
    /// Fetches messages for a specific conversation with pagination
    func fetchMessages(conversationId: String, limit: Int = 30, lastMessageId: String? = nil) async throws -> [Message] {
        print("üîç MessagesService: Fetching messages for conversation: \(conversationId), limit: \(limit), lastMessageId: \(lastMessageId ?? "none")")
        
        var query = db.collection("conversations")
            .document(conversationId)
            .collection("messages")
            .order(by: "timestamp", descending: true)
            .limit(to: limit)
        
        // If we have a lastMessageId, start after that message for pagination
        if let lastMessageId = lastMessageId {
            let lastMessageDoc = try await db.collection("conversations")
                .document(conversationId)
                .collection("messages")
                .document(lastMessageId)
                .getDocument()
            
            if lastMessageDoc.exists {
                query = query.start(afterDocument: lastMessageDoc)
            }
        }
        
        let messagesSnapshot = try await query.getDocuments()
        
        var messages: [Message] = []
        
        for document in messagesSnapshot.documents {
            do {
                let data = document.data()
                let message = Message(
                    id: document.documentID,
                    text: data["text"] as? String ?? "",
                    isFromTrainer: data["senderType"] as? String == "trainer",
                    timestamp: (data["timestamp"] as? Timestamp)?.dateValue() ?? Date()
                )
                messages.append(message)
            } catch {
                print("‚ùå MessagesService: Error decoding message: \(error)")
                continue
            }
        }
        
        // Reverse the array since we fetched in descending order but want to display in ascending order
        messages.reverse()
        
        print("‚úÖ MessagesService: Loaded \(messages.count) messages")
        return messages
    }
    
    /// Fetches messages for a specific conversation (legacy method for backward compatibility)
    func fetchMessages(conversationId: String) async throws -> [Message] {
        return try await fetchMessages(conversationId: conversationId, limit: 30, lastMessageId: nil)
    }
    
    /// Sends a message in a conversation
    func sendMessage(conversationId: String, trainerId: String, clientId: String, clientName: String, text: String, senderId: String, senderType: String) async throws {
        print("üîç MessagesService: Sending message in conversation: \(conversationId)")
        
        // Check if this is an auto-generated conversation (starts with "auto_")
        let actualConversationId: String
        if conversationId.hasPrefix("auto_") {
            // Create a real conversation in Firebase
            let conversationRef = db.collection("conversations").document()
            actualConversationId = conversationRef.documentID
            
            let conversationData: [String: Any] = [
                "id": actualConversationId, // Include the document ID as a field
                "trainerId": trainerId,
                "clientId": clientId,
                "clientName": clientName,
                "lastMessage": text,
                "lastMessageTime": FieldValue.serverTimestamp(),
                "unreadCount": senderType == "client" ? 1 : 0,
                "createdAt": FieldValue.serverTimestamp(),
                "updatedAt": FieldValue.serverTimestamp()
            ]
            
            try await conversationRef.setData(conversationData)
            print("‚úÖ MessagesService: Created new conversation from auto-generated: \(actualConversationId)")
        } else {
            actualConversationId = conversationId
        }
        
        let messageRef = db.collection("conversations")
            .document(actualConversationId)
            .collection("messages")
            .document()
        
        let messageData: [String: Any] = [
            "text": text,
            "senderId": senderId,
            "senderType": senderType,
            "timestamp": FieldValue.serverTimestamp(),
            "isRead": false
        ]
        
        try await messageRef.setData(messageData)
        
        // Update conversation with last message info (if it already existed)
        if !conversationId.hasPrefix("auto_") {
            let conversationRef = db.collection("conversations").document(actualConversationId)
            var conversationUpdate: [String: Any] = [
                "lastMessage": text,
                "lastMessageTime": FieldValue.serverTimestamp(),
                "updatedAt": FieldValue.serverTimestamp()
            ]
            
            // If message is from client, increment unread count for trainer
            if senderType == "client" {
                conversationUpdate["unreadCount"] = FieldValue.increment(Int64(1))
            }
            
            try await conversationRef.updateData(conversationUpdate)
        }
        
        print("‚úÖ MessagesService: Message sent successfully")
    }
    
    /// Marks conversation as read (resets unread count)
    func markConversationAsRead(conversationId: String) async throws {
        try await db.collection("conversations")
            .document(conversationId)
            .updateData([
                "unreadCount": 0,
                "updatedAt": FieldValue.serverTimestamp()
            ])
        
        print("‚úÖ MessagesService: Conversation marked as read: \(conversationId)")
    }
    
    // MARK: - Real-time Listeners
    
    /// Sets up real-time listener for trainer's conversations
    func listenToTrainerConversations(_ trainerId: String, completion: @escaping ([Conversation]) -> Void) {
        print("üîç MessagesService: Setting up conversations listener for trainer: \(trainerId)")
        
        conversationsListener?.remove()
        
        conversationsListener = db.collection("conversations")
            .whereField("trainerId", isEqualTo: trainerId)
            .order(by: "lastMessageTime", descending: true)
            .addSnapshotListener { [weak self] snapshot, error in
                guard let self = self else { return }
                
                if let error = error {
                    print("‚ùå MessagesService: Conversations listener error: \(error)")
                    return
                }
                
                guard let documents = snapshot?.documents else {
                    print("‚ùå MessagesService: No conversations found")
                    completion([])
                    return
                }
                
                let conversations = documents.compactMap { document -> Conversation? in
                    let data = document.data()
                    
                    // Ensure required fields exist
                    guard let clientId = data["clientId"] as? String,
                          let clientName = data["clientName"] as? String else {
                        print("‚ùå MessagesService: Skipping real-time conversation with missing required fields")
                        return nil
                    }
                    
                    return Conversation(
                        id: document.documentID,
                        trainerId: data["trainerId"] as? String ?? "",
                        clientId: clientId,
                        clientName: clientName,
                        lastMessage: data["lastMessage"] as? String ?? "",
                        lastMessageTime: (data["lastMessageTime"] as? Timestamp)?.dateValue() ?? Date(),
                        unreadCount: data["unreadCount"] as? Int ?? 0
                    )
                }
                
                print("‚úÖ MessagesService: Conversations updated - \(conversations.count) conversations")
                completion(conversations)
            }
    }
    
    /// Sets up real-time listener for messages in a conversation with pagination
    func listenToMessages(conversationId: String, limit: Int = 30, completion: @escaping ([Message]) -> Void) {
        print("üîç MessagesService: Setting up messages listener for conversation: \(conversationId), limit: \(limit)")
        
        messagesListener?.remove()
        
        messagesListener = db.collection("conversations")
            .document(conversationId)
            .collection("messages")
            .order(by: "timestamp", descending: true)
            .limit(to: limit)
            .addSnapshotListener { [weak self] snapshot, error in
                guard let self = self else { return }
                
                if let error = error {
                    print("‚ùå MessagesService: Messages listener error: \(error)")
                    return
                }
                
                guard let documents = snapshot?.documents else {
                    print("‚ùå MessagesService: No messages found")
                    completion([])
                    return
                }
                
                let messages = documents.compactMap { document -> Message? in
                    let data = document.data()
                    return Message(
                        id: document.documentID,
                        text: data["text"] as? String ?? "",
                        isFromTrainer: data["senderType"] as? String == "trainer",
                        timestamp: (data["timestamp"] as? Timestamp)?.dateValue() ?? Date()
                    )
                }
                
                // Reverse the array since we fetched in descending order but want to display in ascending order
                let reversedMessages = messages.reversed()
                
                print("‚úÖ MessagesService: Messages updated - \(reversedMessages.count) messages")
                completion(Array(reversedMessages))
            }
    }
    
    /// Stops all listeners
    nonisolated func stopListeners() {
        conversationsListener?.remove()
        messagesListener?.remove()
        print("üõë MessagesService: All listeners stopped")
    }
    
    deinit {
        stopListeners()
    }
}

// MARK: - Enhanced Conversation Model for Firebase
struct EnhancedConversation: Identifiable, Codable {
    let id: String
    let clientId: String
    let clientName: String
    let lastMessage: String
    let lastMessageTime: Date
    let unreadCount: Int
    
    // Convert to original Conversation model for UI compatibility
    var toConversation: Conversation {
        return Conversation(
            clientName: clientName,
            lastMessage: lastMessage,
            lastMessageTime: lastMessageTime,
            unreadCount: unreadCount
        )
    }
}

// MARK: - Conversation Extension for Firebase Compatibility
extension Conversation {
    init(id: String, clientId: String, clientName: String, lastMessage: String, lastMessageTime: Date, unreadCount: Int) {
        self.init(
            clientName: clientName,
            lastMessage: lastMessage,
            lastMessageTime: lastMessageTime,
            unreadCount: unreadCount
        )
    }
} 